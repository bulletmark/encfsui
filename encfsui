#!/bin/bash
###############################################################################
# This bash script provides a simple gui around the encfs command line
# utility to mount and unmount an encrypted directory. This script
# requires encfs, zenity, and xdg-open. See accompaning README.md.
#
# Return code = 0 if no error, else 1.
#
# Copyright (C) 2010 Mark Blakeney. This program is distributed under
# the terms of the GNU General Public License. This program is free
# software: you can redistribute it and/or modify it under the terms of
# the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or any later version.
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License at <http://www.gnu.org/licenses/> for more
# details.
#
# Mark Blakeney, Oct 2010.
# http://github.com/bulletmark/encfsui>
###############################################################################

usage() {
    echo "Usage: `basename $0` [-options] source_enc_dir target_mount_dir"
    echo "GUI utility to mount source_enc_dir to target_mount_dir."
    echo "If target already mounted then it will be unmounted instead."
    echo "Options:"
    echo "-i <mins> specify idle timeout mins"
    echo "-p (make public mount, can only be done by root)"
    echo "-o (don't open target dir in gui mode)"
    exit 1
}

# Process command line options
MINS=""
PUBLIC=""
NOOPEN=0
while getopts i:po? c; do
    case $c in
    i) MINS="--idle $OPTARG";;
    p) PUBLIC="--public";;
    o) NOOPEN=1;;
    ?) usage;;
    esac
done

shift $((OPTIND - 1))

if [ $# -ne 2 ]; then
    usage
fi

# Read source and target dirs. Make absolute path.
src=$(readlink -f $1)
tgt=$(readlink -f $2)

# Check usage
if [ -z "$src" -o -z "$tgt"  ]; then
    usage
fi

# Function to output message using graphical prompt
gui() {
    local title="$1"
    local type="$2"
    local text="$3"

    if [ $type == "entry" ]; then
	args="--hide-text"
    else
	args="--ellipsize --"
    fi

    # Send errors to null to avoid spurious GTK warnings.
    zenity --$type --title="$title encfs directory" \
	--text="$text" --class=EncFSUI $args 2>/dev/null
}

if ! type encfs &>/dev/null; then
    gui Mount error \
    "Sorry, encfs is not installed.\n\nInstall it via your package manager."
    exit 1
fi

# Check if this target is already mounted
if mount | grep -q "^encfs on $tgt "; then

    # Prompt to unmount
    if ! gui Mount question \
	"$tgt is already mounted.\n\nDo you want to unmount it?"; then
	exit 0
    fi

    # Unmount it
    res=$(fusermount -u "$tgt" 2>&1)

    # Output an error if the unmount failed
    if [ $? -ne 0 ]; then
	gui Unmount error "$res"
	exit 1
    fi

    # Remove target dir if it is empty
    rmdir "$tgt" &>/dev/null
    exit 0
fi

open-dir-gui() {
    local dir="$1"
    xdg-open $dir &>/dev/null &
}

# Mount the directory. Check first that this is an encfs filesystem
if ! encfsctl "$src" &>/dev/null; then
    gui Mount error \
    "$src does not exist or is not an encfs filesystem.\nCreate it manually with encfs. E.g. Run the following and answer the prompts.\n\nencfs ~/.Private ~/Private\n\nSee man encfs for more options and details."
    exit 1
fi

# Create target dir if it doesn't exist
mkdir -p "$tgt" &>/dev/null

# Loop on user entry for passphrase ..
mounted=0
while true; do

    # Get passphrase from user
    res=$(gui Mount entry "Mount $src to $tgt\n\nWhat is the passphrase?")

    # User may cancel. Note that encfs has a bug such that it
    # does not intercept this case if you use the --extpass
    # option. That's why we are calling zenity and encfs
    # explicity ourselves.
    if [ $? -ne 0 ]; then
	break
    fi

    # Give passphrase to encfs and mount the file system
    res=$(echo "$res" | encfs -S $PUBLIC $MINS "$src" "$tgt" 2>&1)

    # Check for error (typically a bad passphrase)
    if [ $? -eq 0 ]; then
	if [ $NOOPEN -eq 0 ]; then
	    open-dir-gui "$tgt"
	fi

	mounted=1
	break
    fi

    gui Mount error "$res"
done

if [ $mounted -eq 0 ]; then
    rmdir "$tgt" &>/dev/null
fi

exit 0
